title: 一个数字截取引发的精度问题（四）
date: 2017-03-18 18:24:21
 - javascript
tags:
 - float double 精度
---

做前端的都感觉JS这语言巨坑无比，兼容性让你摸不到头脑。一些初学者遇到：

    0.1 + 0.2 = 0.30000000000000004

都会觉得这JS太TM坑了，一个小数计算都不会。可是我想说，这"锅"JS不背！其实和JS采用的数值存储 [IEEE754](http://grouper.ieee.org/groups/754/) 规范有关，
所有采用此规范的语言都会有此问题并不是JS的"锅"。

IEEE754

>IEEE浮点数算术标准（IEEE 754）是最广泛使用的浮点数运算标准，为许多CPU与浮点运算器所采用，单精确度（32位）、双精确度（64位）、延伸单精确度（43位以上，很少使用）与延伸双精确度（79位元以上，通常以80位元实做）

计算机中是用有限的连续字节保存浮点数的。 JS采用64位（双精度）存储数据，在 IEEE 标准中，浮点数是将所有二进制位分割为特定宽度的符号域（S），指数域(E)和尾数域(F)三个域， 其中保存的值分别用于表示给定二进制浮点数中的符号，指数和尾数。

根据国际标准IEEE 754，任意一个二进制浮点数V可以表示成下面的形式：

    V = (-1)^s×M×2^E
    
 1. (-1)^s表示符号位，当s=0，V为正数；当s=1，V为负数。
 2. M表示有效数字，大于等于1，小于2，但整数部分的1可以省略。
 3. 2^E表示指数位。
 
 对于十进制的5.25对应的二进制为：101.01，相当于：```1.0101*2^2```。所以，S为0，M为1.0101，E为2。
 而```-5.25=-101.01=-1.0101*2^2```。所以S为1，M为1.0101，E为2。


复习一下[十进制转2进制](https://zh.wikipedia.org/zh-hans/%E4%BA%8C%E8%BF%9B%E5%88%B6)：

口诀

>整数部分除2取余，由下到上；小数部分乘2取整，由上到下。

0.1 在计算机中如何存储？

首先 0.1 转化为二进制：0.000110011（0011循环）套用公式可得：

    (-1)^0*1.1001*2^-4
    
所以 s:0，M:1.1001(循环1001)，E:-4。

由于小数位仅储存 52bit, 储存时会将超出精度部分进行"零舍一入"，

无限精确值：

    1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001
    
实际储存值：

    1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010
    
此处精度已经丢失一次。最后0.1实际存储为：

    0.0001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010

同理计算出0.2的实际存储值（同样也存在精度丢失）：

    0.001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010
    
两数相加得：

    0.01001100110011001100110011001100110011001100110011001110
    
再转为十进制：0.30000000000000004。

在线转换工具：http://tool.oschina.net/hexconvert。