<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>关于生活，关于前端</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="wumiiVerification" content="e6510660-240e-4909-8068-663f55fc7795" />
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="关于生活，关于前端">
<meta property="og:url" content="http://zhuxinyong.com/index.html">
<meta property="og:site_name" content="关于生活，关于前端">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="关于生活，关于前端">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="关于生活，关于前端" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  
<script type="text/javascript">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?8c6506f2771c14e5184e4b40cb38aac2";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

  <script src="http://libs.baidu.com/jquery/1.9.0/jquery.js"></script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<div class="profilepic">
			<img src="https://avatars0.githubusercontent.com/u/745181?v=2&amp;s=460">
		</div>

		<hgroup>
		  <h1 class="header-author"><a href="/">Zhuxy</a></h1>
		</hgroup>

		

		
			<div class="onoffswitch">
			    <input type="checkbox" name="onoffswitch" class="onoffswitch-checkbox" id="myonoffswitch" checked>
			    <label class="onoffswitch-label" for="myonoffswitch">
			        <span class="onoffswitch-inner"></span>
			        <span class="onoffswitch-switch"></span>
			    </label>
			</div>
		

		<div class="switch-area">
			<section class="first-part">
				<nav class="header-menu">
					<ul>
					
						<li><a href="/">主页</a></li>
			        
						<li><a href="/archives">所有文章</a></li>
			        
						<li><a href="/about">关于</a></li>
			        
					</ul>
				</nav>
				<nav class="header-nav">
					<div class="social">
						
							<a class="github" target="_blank" href="https://github.com/ghostcode" title="github">github</a>
				        
							<a class="weibo" target="_blank" href="http://weibo.com/ghostcode" title="weibo">weibo</a>
				        
					</div>
				</nav>
			</section>
			
			
			<section class="second-part">
				<div class="widget tagcloud">
					<a href="/tags/Ajax/" style="font-size: 10px;">Ajax</a> <a href="/tags/ES6/" style="font-size: 10px;">ES6</a> <a href="/tags/Express/" style="font-size: 10px;">Express</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Grunt/" style="font-size: 10px;">Grunt</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Javascript/" style="font-size: 20px;">Javascript</a> <a href="/tags/Mac/" style="font-size: 10px;">Mac</a> <a href="/tags/Node/" style="font-size: 10px;">Node</a> <a href="/tags/Node-Express/" style="font-size: 10px;">Node Express</a> <a href="/tags/Sublime/" style="font-size: 20px;">Sublime</a> <a href="/tags/chrome/" style="font-size: 10px;">chrome</a> <a href="/tags/css3/" style="font-size: 10px;">css3</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/promise/" style="font-size: 10px;">promise</a> <a href="/tags/regexp/" style="font-size: 10px;">regexp</a> <a href="/tags/webcomponents/" style="font-size: 10px;">webcomponents</a> <a href="/tags/架构/" style="font-size: 10px;">架构</a> <a href="/tags/浏览器/" style="font-size: 10px;">浏览器</a> <a href="/tags/特效/" style="font-size: 10px;">特效</a>
				</div>
			</section>
			
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay"></div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="https://avatars0.githubusercontent.com/u/745181?v=2&amp;s=460">
			</div>

			<hgroup>
			  <h1 class="header-author"><a href="/">Zhuxy</a></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/about">关于</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/ghostcode" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/ghostcode" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      
  
    <article id="post-ES6的6个小特性（二）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/26/ES6的6个小特性（二）/" class="article-date">
  	<time datetime="2016-11-26T14:50:31.000Z" itemprop="datePublished">Nov 26 2016</time>
</a>
      
      
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/26/ES6的6个小特性（二）/">ES6的6个小特性（二）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>继上一篇的 <a href="http://zhuxinyong.com/2016/11/15/ES6%E7%9A%846%E4%B8%AA%E5%B0%8F%E7%89%B9%E6%80%A7/">《Six Tiny But Awesome ES6 Features》</a>，这次我再分享6个可以减少代码和最大化效率的方法。</p>
<p><strong> 1.Object Shorthand </strong></p>
<p>新的对象声明方法允许我们可以不声明对象的 key :</p>
<pre><code><span class="variable"><span class="keyword">var</span> x</span> = <span class="number">12</span>;
<span class="variable"><span class="keyword">var</span> y</span> = yes;
<span class="variable"><span class="keyword">var</span> z</span> = {one:'<span class="number">1</span>',two:'<span class="number">2</span>'};

<span class="comment">// The old way</span>
<span class="variable"><span class="keyword">var</span> obj</span> = {
    x:x,
    y:y,
    z:z
}
<span class="comment">// The new way</span>
<span class="variable"><span class="keyword">var</span> obj</span> = {x,y,z};
</code></pre><p><strong> 2.Method Properties </strong></p>
<p>避免 function 关键字声明函数：</p>
<pre><code><span class="variable"><span class="keyword">var</span> davidwalsh</span> = {
    makeItHappen(param){
        <span class="comment">// do stuff</span>
    }
}
</code></pre><p>必须承认去除掉 function 关键字确实使代码简洁、更好维护。</p>
<p><strong> 3.Blocks vs Immediately Executed Functions </strong></p>
<p>下面创建立即执行方法的模式有点难看：</p>
<pre><code><span class="list">(<span class="keyword">function</span><span class="list">()</span><span class="collection">{
    // do stuff
}</span>)</span><span class="list">()</span><span class="comment">;</span>
</code></pre><p>通过ES6我们可以通过 {} 和 let 来创建块级作用于，完成立即执行函数的作用：</p>
<pre><code>{
    <span class="keyword">let</span> j = <span class="number">12</span>;
    <span class="keyword">let</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);

    <span class="pi">// do stuff
}

j; //</span> <span class="attribute">ReferenceError</span>: j <span class="keyword">is</span> <span class="keyword">not</span> defined...
</code></pre><p> 如果在 Block 内部声明函数，它将会被外部访问到。但你如果使用 let 关键字声明函数自变量，将不使用括号的情况下实现 IEF 的功能。</p>
<p><strong> 4. for loops and let </strong></p>
<p> 因为在JS里面会存在变量提升，我们经常会在作用域前面声明一些”无用”的迭代变量，例如（for var x = …）。ES6 使用 let 解决了此恼人的问题：</p>
<pre><code><span class="keyword">for</span>(let x = <span class="number">0</span>; x &lt; len; i++){
    <span class="regexp">//do</span> stuff
}

x; <span class="regexp">//</span> <span class="constant">ReferenceError:</span> x is <span class="keyword">not</span> <span class="keyword">defined</span>
</code></pre><p> 不久以后 let 会被应用的更多。</p>
<p><strong> 5.get and set for Classes </strong></p>
<pre><code><span class="keyword">class</span> Cart{
    <span class="constructor"><span class="keyword">constructor</span>(total)</span>{
        <span class="keyword">this</span>._total = total;
    }
    <span class="keyword">get</span> total(){<span class="keyword">return</span> <span class="keyword">this</span>._total;}
    <span class="keyword">set</span> total(v){<span class="keyword">this</span>._total = <span class="built_in">Number</span>(v);}
}

<span class="keyword">var</span> cart = <span class="keyword">new</span> Cart(<span class="number">100</span>);

cart.total <span class="comment">// 100</span>
</code></pre><p> 能为属性设置 get、set 是这部分最棒的。不需要使用函数来进行特殊的设定–当执行 obj.prop = {value} 时，一切都会自动执行。</p>
<p><strong> 6.startsWith,endsWith and includes </strong></p>
<pre><code><span class="string">"MooTools"</span>.startsWith(<span class="string">"Moo"</span>); <span class="regexp">//</span> <span class="keyword">true</span>;
<span class="string">"MooTools"</span>.startsWith(<span class="string">"moo"</span>); <span class="regexp">//</span> <span class="keyword">false</span>;

<span class="string">"MooTools"</span>.endsWith(<span class="string">"Tools"</span>); <span class="regexp">//</span> <span class="keyword">true</span>;

<span class="string">"MooTools"</span>.includes(<span class="string">"oo"</span>); <span class="regexp">//</span> <span class="keyword">true</span>;
</code></pre><p> 注：includes 方法兼容性还是很多，曾有一个线上bug，就是因为不支持此方法导致的。</p>
<p> 原文：<a href="https://davidwalsh.name/es6-features-ii/amp" target="_blank" rel="external">https://davidwalsh.name/es6-features-ii/amp</a></p>

      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>






  
    <article id="post-ES6的6个小特性" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/15/ES6的6个小特性/" class="article-date">
  	<time datetime="2016-11-15T13:07:46.000Z" itemprop="datePublished">Nov 15 2016</time>
</a>
      
      
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/15/ES6的6个小特性/">ES6的6个小特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>JS社区的每个人都喜欢新的API、语法以及一些简单、明了更高效的完成重要任务的新特性。过去一年ES6带来了十足的进步，下面是6个我最喜欢的JS新增特性。</p>
<p><strong>1.Object[key]</strong></p>
<p>有时候不能在对象变量声明时设置所有的key/value，所以得再声明之后添加key/value。</p>
<pre><code><span class="keyword">let</span> myKey = <span class="string">'key3'</span>;
<span class="keyword">let</span> obj = {
    key1: <span class="string">'One'</span>,
    key2: <span class="string">'Two'</span>
};
obj[myKey] = <span class="string">'Three'</span>;
</code></pre><p>往好的说这有点不方便，往坏的说这种方式令人疑惑而且有点丑陋。ES6提供给开发者一种更优雅的方式：</p>
<pre><code><span class="keyword">let</span> myKey = <span class="string">'variableKey'</span>;
<span class="keyword">let</span> obj = {
    key<span class="number">1</span>: <span class="string">'One'</span>,
    key<span class="number">2</span>: <span class="string">'Two'</span>,
    [myKey]: <span class="string">'Three'</span> <span class="comment">/* yay! */</span>
};
</code></pre><p>开发者可以使用<code>[]</code>包裹变量从而使用一条语句完成所有的功能。</p>
<p><strong>2.Arrow Functions</strong></p>
<p>你不需要跟上ES6的所有改变，箭头函数已经是许多讨论的话题并且也给JS开发者带来了一些困惑。即使我可以写很多博文来说箭头函数的特点，但是我想指出箭头函数是如何提供一个为简单函数压缩代码的方法。</p>
<pre><code><span class="comment">// Adds a 10% tax to total</span>
let calculateTotal = total =&gt; total * <span class="number">1.1</span>;
calculateTotal(<span class="number">10</span>) <span class="comment">// 11</span>

<span class="comment">// Cancel an event -- another tiny task</span>
let brickEvent = e =&gt; e.preventDefault();
<span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">'div'</span>).addEventListener(<span class="string">'click'</span>, brickEvent);
</code></pre><p>无<code>functions</code>和<code>return</code>关键词，有时甚至不需要添加<code>()</code>，箭头函数为写函数提供了一种简短的代码书写方式。</p>
<p><strong>find/findIndex</strong></p>
<p>JS为开发者提供了<code>Array.prototype.indexOf</code>方法来获取数组中的指定元素下标，但是<code>indexOf</code>并没有提供一个根据判断条件来获取指定元素的方法，<code>find</code>和<code>findIndex</code>两个方法提供了取出第一个满足计算条件的元素和下标。</p>
<pre><code>let age = [<span class="number">12</span>,<span class="number">19</span>,<span class="number">6</span>,<span class="number">4</span>];

let firstAdult = ages.find(age =&gt; age &gt;= <span class="number">18</span>); <span class="comment">// 19</span>
let firstAdultIndex = ages.findIndex(age =&gt; age &gt;= <span class="number">19</span>); <span class="comment">// 1</span>
</code></pre><p><strong>…扩展修饰符</strong></p>
<p>扩展修饰符表示数组和可迭代对象在调用的时候应该拆分成单个参数：</p>
<pre><code><span class="comment">// Pass to function that expects separate multiple arguments</span>
<span class="comment">// Much like Function.prototype.apply() does</span>
<span class="keyword">let</span> numbers = [<span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>];
<span class="built_in">Math</span>.min(...numbers); <span class="comment">// 1</span>

<span class="comment">// Convert NodeList to Array</span>
<span class="keyword">let</span> divsArray = [...document.querySelectorAll(<span class="string">'div'</span>)];

<span class="comment">// Convert Arguments to Array</span>
<span class="keyword">let</span> argsArray = [...arguments];
</code></pre><p>这个特定的另一个红利可以把可迭代对象（<code>NodeList</code>、<code>arguments</code>）变成真的数组，以前我们经常使用<code>Array.from</code>或其他方法实现的。</p>
<p><strong>Template Literals</strong></p>
<p>JS里多行字符起初通过<code>+</code>和<code>\</code>来完成的，但是都很难维护。许多开发者甚至一些框架使用<code>&lt;script&gt;</code>标签来容纳模板，然后使用DOM方法的<code>outerHTML</code>来获取HTML字符。</p>
<p>ES6提供了<code>Template Literals</code>使用反引号来容易的创建多行字符串：</p>
<pre><code><span class="comment">// Multiline String</span>
<span class="keyword">let</span> myString = <span class="string">`Hello

I'm a new line`</span>;

<span class="comment">//Basic interpolations</span>
<span class="keyword">let</span> obj = {x:<span class="number">1</span>,y:<span class="number">2</span>};

<span class="built_in">console</span>.log(<span class="string">`Your total is: <span class="subst">${obj.x + obj.y}</span>`</span>); <span class="comment">// Your total is 3</span>
</code></pre><p><strong>Default Argument Values</strong></p>
<p>为函数参数提供默认值在服务端语言已经提供（python、php），现在JS也有此能力：</p>
<pre><code>//Basic usage

<span class="function"><span class="keyword">function</span></span> great( <span class="keyword">name</span> = <span class="string">'Anon'</span> ){
    console.<span class="built_in">log</span>(`Hello ${<span class="keyword">name</span>}`);
}

great(); // Hello Anon<span class="comment">!</span>

//You can have a <span class="function"><span class="keyword">function</span></span> too<span class="comment">!</span>

<span class="function"><span class="keyword">function</span></span> greet( <span class="keyword">name</span> = <span class="string">'Anon'</span>,callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{} ){
    console.<span class="built_in">log</span>(`Hello ${<span class="keyword">name</span>}<span class="comment">!`);</span>
    // No more <span class="string">"callback &amp;&amp; callback()"</span> (no conditional)
    callback();
}

// <span class="keyword">Only</span> set a <span class="keyword">default</span> for one <span class="type">parameter</span>
<span class="function"><span class="keyword">function</span></span> greet(<span class="keyword">name</span>, callback = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{}) {}
</code></pre><p>以上列出的6个特性就是ES6提供给开发者，当然还有许多特性。</p>
<p>评论里提供的：</p>
<p>1 . </p>
<pre><code>const isRequired = <span class="function"><span class="params">()</span> =&gt;</span> {<span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'param is required'</span>);};

const hello = <span class="function"><span class="params">(name = isRequired())</span> =&gt;</span> { <span class="built_in">console</span>.log(`<span class="javascript">hello ${name}</span>`) };
</code></pre><p>2 . </p>
<pre><code><span class="keyword">const</span> <span class="keyword">is</span> = {
    <span class="function"><span class="keyword">get</span> <span class="title">required</span>(<span class="params"></span>)</span>{
        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Required argument'</span>)
    }
}

import {<span class="keyword">is</span>} <span class="keyword">from</span> <span class="string">'utils'</span>

<span class="function"><span class="keyword">const</span> <span class="title">foo</span>(<span class="params">name = <span class="keyword">is</span>.required</span>) </span>=&gt; Array.<span class="keyword">from</span>(name)
</code></pre><p>原文：<a href="https://davidwalsh.name/es6-features" target="_blank" rel="external">https://davidwalsh.name/es6-features</a></p>

      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>






  
    <article id="post-枚举对象属性几种方法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/08/07/枚举对象属性几种方法/" class="article-date">
  	<time datetime="2016-08-07T09:46:00.000Z" itemprop="datePublished">Aug 7 2016</time>
</a>
      
      
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/07/枚举对象属性几种方法/">枚举对象属性几种方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>_.keys</p>
<p>_.allKeys</p>
<p>for…in</p>
<p>for…of</p>
<p>in</p>
<p>Object.keys</p>

      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>






  
    <article id="post-静默一切console-log和alert" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/29/静默一切console-log和alert/" class="article-date">
  	<time datetime="2016-04-29T04:19:30.000Z" itemprop="datePublished">Apr 29 2016</time>
</a>
      
      
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/29/静默一切console-log和alert/">静默一切console.log和alert</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>开发的时候可以打开静默，上线可以静默：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 备份以备后用</span></span><br><span class="line"><span class="keyword">var</span> __log = <span class="built_in">console</span>.log;</span><br><span class="line"><span class="keyword">var</span> __alert = <span class="built_in">window</span>.alert;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//静默 console.log alert</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mute</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="built_in">window</span>.alert = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打开静默</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unmute</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log = __log;</span><br><span class="line">    <span class="built_in">window</span>.alert = __alert;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>






  
    <article id="post-移动端调试" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/17/移动端调试/" class="article-date">
  	<time datetime="2016-04-17T04:31:26.000Z" itemprop="datePublished">Apr 17 2016</time>
</a>
      
      
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/17/移动端调试/">移动端调试</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>PC端调试两大利器：Firefox的Firebug和Chrome的<a href="https://developer.chrome.com/devtools" target="_blank" rel="external">devtools</a>，有这两个东西PC端的调试基本没有什么问题。但是随着前端的移动开发需求越来越多，移动端的调试也渐渐被大家重视。可是移动端没有像PC那样方便，但是解决方法还是有的。</p>
<p>我大体分三种移动端调试需求：</p>
<p><strong>1.浏览器的页面调试（mobile web page）</strong></p>
<p>1.1 iOS的Safari</p>
<blockquote>
<p>手机端：设置 → Safari → 高级 → Web 检查器 → 开。</p>
<p>mac端：Safari → 偏好设置 → 高级 → 在菜单栏中显示“开发”菜单。</p>
</blockquote>
<p><img src="/assets/images/safari.png" alt="ios-debugger"><br><img src="/assets/images/safari2.png" alt="ios-debugger"><br><img src="/assets/images/safrai.png" alt="ios-debugger"></p>
<p>最后数据线连接电脑和手机或者打开模拟器，Mac里的Safari(如下图)都可以看到连接的设备，点到对应的页面就可以调试:</p>
<p><img src="/assets/images/mac-safari.png" alt="ios-debugger"></p>
<p>1.2 iOS设备模拟器</p>
<p><img src="/assets/images/ios.png" alt="ios-debugger"><br><img src="/assets/images/add-simulator.png" alt="ios-debugger"><br><img src="/assets/images/ios-simulator-6.png" alt="ios-debugger"></p>
<p>注：iOS模拟设备里的Safari打开调试模式和上面一样。</p>
<p>以前搞Swift开发时，遇到模拟器无法弹起键盘：</p>
<p><img src="/assets/images/ios-simulator-keyboarad.png" alt="ios-debugger"></p>
<p>1.2 Android</p>
<p>直接复制<a href="https://developer.chrome.com/devtools/docs/remote-debugging" target="_blank" rel="external">官网</a>的一些调试条件：</p>
<ul>
<li>Chrome 32 or later installed on your development machine.</li>
<li>A USB cable to connect your Android device.</li>
<li>For browser debugging: Android 4.0+ and Chrome for Android.</li>
<li>For app debugging: Android 4.4+ and a WebView configured for debugging.</li>
</ul>
<p>以上可知不能调试低版本Android或者安装的其它浏览器，解决版本和微信里面相同。</p>
<p><strong>2.微信内嵌页面</strong></p>
<p>调试微信内嵌页和低版本安卓使用<a href="http://people.apache.org/~pmuellr/weinre/docs/latest/Home.html" target="_blank" rel="external">weinre</a>：</p>
<blockquote>
<p>npm -g install weinre</p>
</blockquote>
<p>控制台使用下面方法启动：</p>
<blockquote>
<p>weinre –boundHost -all-</p>
</blockquote>
<p>具体调试方法看官网。</p>
<p>参考：</p>
<ol>
<li><a href="https://www.smashingmagazine.com/2014/09/testing-mobile-emulators-simulators-remote-debugging/" target="_blank" rel="external">https://www.smashingmagazine.com/2014/09/testing-mobile-emulators-simulators-remote-debugging/</a></li>
<li><a href="https://github.com/nupthale/weinre" target="_blank" rel="external">https://github.com/nupthale/weinre</a></li>
<li><a href="https://github.com/jieyou/remote_inspect_web_on_real_device" target="_blank" rel="external">https://github.com/jieyou/remote_inspect_web_on_real_device</a></li>
<li><a href="https://segmentfault.com/a/1190000000459296" target="_blank" rel="external">https://segmentfault.com/a/1190000000459296</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>






  
    <article id="post-throttle与debounce的区别" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/09/throttle与debounce的区别/" class="article-date">
  	<time datetime="2016-04-09T07:46:14.000Z" itemprop="datePublished">Apr 9 2016</time>
</a>
      
      
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/09/throttle与debounce的区别/">throttle与debounce的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>以前写过一篇文章<a href="http://zhuxinyong.com/2016/01/03/%E2%80%9C%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0%E2%80%9D%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD/">《“节流函数”提高性能》</a>，里面讲到用函数“节流”来减少执行次数（不影响体验的情况下），其实实现的代码并没有问题，但是第二个方法的函数名有问题。前几天看到一篇文章，我的公众号里也分享了《一次发现underscore源码bug的经历以及对学术界拿来主义的思考》具体文章详见，微信公众号：<img src="/assets/images/heibanbao.jpg" alt="img">。</p>
<p>文中讲了大家对throttle和debounce存在误解，同时提到了《高程3》中实现节流方法存在一些问题，为了更好的理解这两个概念，搜了很多相关文章，详见文章底部。</p>
<p>throttle与debounce是两个类似的概念，目的都是随着时间的推移控制执行函数的次数，但是有些细微的差别。</p>
<p>当我们为DOM事件关联方法时，若我们有一个debounced和throttled函数将会很方便，为何？因为这样我们可以在事件和执行函数之间添加一层控制，注意我们并没有去控制DOM事件触发的次数。</p>
<p>例如，我们谈一下scroll事件，看下面的例子：</p>
<p></p><p data-height="268" data-theme-id="0" data-slug-hash="xVpoOe" data-default-tab="result" data-user="ghostcode" class="codepen">See the Pen <a href="http://codepen.io/ghostcode/pen/xVpoOe/" target="_blank" rel="external">Scroll events counter</a> by ghostcode (<a href="http://codepen.io/ghostcode" target="_blank" rel="external">@ghostcode</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<p>当你在触控板或者鼠标滚动时，每次最少会达到30次，在手机上更多。可是你的滚动事件处理函数对这个频率是否应付的过来？</p>
<p>在2011年，Twitter网站曾爆出一个问题：当你在主页往下滚动时，页面会变得缓慢以致没有响应。John Resig发表了一篇文章<a href="http://ejohn.org/blog/learning-from-twitter/" target="_blank" rel="external">《 a blog post about the problem》</a>指出直接在scroll事件上面绑定高消耗的事件是一个多么愚蠢的想法。</p>
<p>在那个时候John建议使用一个独立于scroll事件且每250ms执行的轮询方法。这样的话处理方法就不会耦合于事件。通过这个简单的技术，我们可以提高用户体验。</p>
<p>现在有一些更先进的事件处理方法，让我来给你介绍：<strong>Debounce，Throttle和requestAnimationFrame</strong>，同时会介绍一些适用的场景。</p>
<p><strong>Debounce</strong></p>
<p>Debounce技术使我们可以将一个连续的调用归为一个。</p>
<p><img src="../assets/images/debounce.png" alt="img"></p>
<p>想象你在电梯的场景，当电梯门开始要关闭的时候，突然一个人进来，此时电梯并不会关闭并且也不会执行改变楼层的方法，如果还有人进来同样的事情会发生：电梯延迟执行它的方法（改变楼层），优化了它的资源。</p>
<p>自己尝试一下，在按钮上点击或者移动鼠标：</p>
<p></p><p data-height="268" data-theme-id="0" data-slug-hash="vGpqLO" data-default-tab="result" data-user="ghostcode" class="codepen">See the Pen <a href="http://codepen.io/ghostcode/pen/vGpqLO/" target="_blank" rel="external">Debounce. Trailing</a> by ghostcode (<a href="http://codepen.io/ghostcode" target="_blank" rel="external">@ghostcode</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<p>你可以看到快速连续的事件是如何通过一个debounce事件来表示的。</p>
<p><strong>Leading edge (or “immediate”)</strong></p>
<p>你可以发现事件结束的时候，debounce的事件并没有立即执行而是等待了一些时间才触发。为何不立即触发，就像开始没有使用debounce事件处理？直到在连续执行的事件中有一个暂停，才会再次触发。</p>
<p>你可以通过一个<strong>leading</strong>的参数做到：</p>
<p><img src="../assets/images/debounce-leading.png" alt="img"></p>
<p>在underscore.js中，这个参数叫immediate。</p>
<p>自己尝试一下：</p>
<p></p><p data-height="268" data-theme-id="0" data-slug-hash="VaQwRm" data-default-tab="result" data-user="ghostcode" class="codepen">See the Pen <a href="http://codepen.io/ghostcode/pen/VaQwRm/" target="_blank" rel="external">Debounce. Leading</a> by ghostcode (<a href="http://codepen.io/ghostcode" target="_blank" rel="external">@ghostcode</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<p><strong>Debounce Implementations</strong></p>
<p>2009年在<a href="http://unscriptable.com/2009/03/20/debouncing-javascript-methods/" target="_blank" rel="external">John Hann的文章</a>中第一次看到debounce的实现方法。</p>
<p>在那之后不久，Ben Alman写了一个<a href="http://benalman.com/projects/jquery-throttle-debounce-plugin/" target="_blank" rel="external">jQuery插件</a>(现在不在维护)，一年以后Jeremy Ashkenas把此方法添加到<a href="https://github.com/jashkenas/underscore/commit/9e3e067f5025dbe5e93ed784f93b233882ca0ffe" target="_blank" rel="external">underscore.js</a>中，不久又被添加到lodash中。</p>
<p></p><p data-height="268" data-theme-id="0" data-slug-hash="GZQRLv" data-default-tab="result" data-user="ghostcode" class="codepen">See the Pen <a href="http://codepen.io/ghostcode/pen/GZQRLv/" target="_blank" rel="external">debounce-click</a> by ghostcode (<a href="http://codepen.io/ghostcode" target="_blank" rel="external">@ghostcode</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<p>这三种实现方法内部不同，但是接口几乎一致。</p>
<p>有段时间underscore采用了Lodash的实现方法，但是在我发现了一个<a href="http://drupalmotion.com/article/debounce-and-throttle-visual-explanation" target="_blank" rel="external">bug</a>之后，自此两个库的实现开始分道扬镳。</p>
<p>Lodash在<em>.debounce和</em>.throttle中添加了许多特性。immediate标示替代了leading和trailing。你可以二选一或者都选，默认情况下，只有trailing是开启的。</p>
<p><strong>Debounce Examples</strong></p>
<p>当改变浏览器窗口时，resize事件会触发多次。</p>
<p></p><p data-height="268" data-theme-id="0" data-slug-hash="PNQorE" data-default-tab="result" data-user="ghostcode" class="codepen">See the Pen <a href="http://codepen.io/ghostcode/pen/PNQorE/" target="_blank" rel="external">Debounce Resize Event Example</a> by ghostcode (<a href="http://codepen.io/ghostcode" target="_blank" rel="external">@ghostcode</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<p>如你所见，我们使用了<strong>trailing</strong>参数，因为我们只对用户停止改变浏览器大小时最后一次事件感兴趣。</p>
<p><strong>AutoComplete中的Ajax请求使用的keypress</strong></p>
<p>当用户仍旧在输入的时候，为何每隔50ms发送Ajax请求？<strong> _.debounce </strong>可以帮助我们避免额外的工作，只在用户停止输入的时候发送请求。</p>
<p></p><p data-height="268" data-theme-id="0" data-slug-hash="wGyvVj" data-default-tab="result" data-user="ghostcode" class="codepen">See the Pen <a href="http://codepen.io/ghostcode/pen/wGyvVj/" target="_blank" rel="external">Debouncing keystrokes Example</a> by ghostcode (<a href="http://codepen.io/ghostcode" target="_blank" rel="external">@ghostcode</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<p>另一个使用场景是在进行input校验的时候，“你的密码太短”等类似的信息。</p>
<p><strong>如何使用debounce和throttle以及常见的陷阱？</strong></p>
<p>可以自己实现这两个方法或者随便复制别人blog中的实现方法，我的建议是直接使用underscore和lodash中的方法。如果你只需要这两个方法，可以定制输出lodash方法：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i -<span class="keyword">g</span> lodash-<span class="keyword">cli</span></span><br><span class="line">lodash-<span class="keyword">cli</span> <span class="keyword">include</span>=debounce,throttle</span><br></pre></td></tr></table></figure>
<p>一个常见的陷阱：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WRONG</span></span><br><span class="line">$(<span class="built_in">window</span>).on(<span class="string">'scroll'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   _.debounce(doSomething, <span class="number">300</span>); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// RIGHT</span></span><br><span class="line">$(<span class="built_in">window</span>).on(<span class="string">'scroll'</span>, _.debounce(doSomething, <span class="number">200</span>));</span><br></pre></td></tr></table></figure>
<p>debounce方法赋值给一个变量之后允许我们调用一个私有方法：<strong>debounced_version.cancel()</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> debounced_version = _.debounce(doSomething, <span class="number">200</span>);</span><br><span class="line">$(<span class="built_in">window</span>).on(<span class="string">'scroll'</span>, debounced_version);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If you need it</span></span><br><span class="line">debounced_version.cancel();</span><br></pre></td></tr></table></figure>
<p><strong>Throttle</strong></p>
<p>使用<strong> _.throttle </strong>，我们不允许方法在每Xms间执行超过一次。</p>
<p>和debounce的主要区别是throttle保证方法每Xms有规律的执行。</p>
<p><strong>Throttling Examples</strong></p>
<p>一个相当常见的例子，用户在你无限滚动的页面上向下拖动，你需要判断现在距离页面底部多少。如果用户快接近底部时，我们应该发送请求来加载更多内容到页面。</p>
<p>在此<strong> _.debounce </strong>没有用，因为它只会在用户停止滚动时触发，但我们需要用户快到达底部时去请求。通过<strong> _.throttle </strong>我们可以不间断的监测距离底部多远。</p>
<p></p><p data-height="268" data-theme-id="0" data-slug-hash="xVYbGZ" data-default-tab="result" data-user="ghostcode" class="codepen">See the Pen <a href="http://codepen.io/ghostcode/pen/xVYbGZ/" target="_blank" rel="external">Infinite scrolling throttled</a> by ghostcode (<a href="http://codepen.io/ghostcode" target="_blank" rel="external">@ghostcode</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<p><strong>requestAnimationFrame (rAF)</strong></p>
<p>requestAnimationFrame是另一个频率限制的方法。</p>
<p>它可以通过<strong> _.throttle(dosomething, 16)</strong>实现，但为了更加精准浏览器提供了内置API。</p>
<p>我们可以使用rAF API作为throttle方法的替代，考虑一下利弊：</p>
<p>利：</p>
<ul>
<li>目标60fps（16ms每贞），但是内部使用最优的时间间隔来渲染</li>
<li>使用简单并且是标准API，以后不会变动，不需要维护</li>
</ul>
<p>弊：</p>
<ul>
<li>rAF的开始或者取消需要我们自己处理，不像.debounce和.throttle内部实现</li>
<li>浏览器Tag没有激活，它就不会执行</li>
<li>即使多数现代浏览器支持，但是IE9，Opera Mini以及老版本Android依旧不支持。<a href="http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/" target="_blank" rel="external">A polyfill</a>到现在依旧<a href="http://caniuse.com/#feat=requestanimationframe" target="_blank" rel="external">需要</a></li>
<li>rAF在node.js中不支持</li>
</ul>
<p>根据经验，我建议在JS执行”painting”或”animating”中直接操作属性和重新计算元素位置时使用rAF。</p>
<p>发送Ajax请求或者是否添加／删除class（触发一个CSS动画）时，我会考虑debounce和throttle，此时你可以降低执行频率（200ms而不是16ms）。</p>
<p><strong>rAF的例子</strong></p>
<p>在<a href="http://www.html5rocks.com/en/tutorials/speed/animations/" target="_blank" rel="external">Paul Lewis的文章</a>激发下，我只在scroll事件中提供例子。</p>
<p>我一步步的调throttle到16ms，希望给一个类似的体验，但是rAF在复杂场景下或许会提供更好的结果。</p>
<p></p><p data-height="268" data-theme-id="0" data-slug-hash="qZxEaq" data-default-tab="result" data-user="ghostcode" class="codepen">See the Pen <a href="http://codepen.io/ghostcode/pen/qZxEaq/" target="_blank" rel="external">Scroll comparison requestAnimationFrame vs throttle</a> by ghostcode (<a href="http://codepen.io/ghostcode" target="_blank" rel="external">@ghostcode</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<p>一个更好的例子我是在headroom.js中看到的，这里通过一个对象封装，进行了<a href="https://github.com/WickyNilliams/headroom.js/blob/3282c23bc69b14f21bfbaf66704fa37b58e3241d/src/Debouncer.js" target="_blank" rel="external">逻辑解藕</a>。</p>
<p><strong>总结：</strong><br>使用debounce，throttle和requestAnimationFrame优化你的事件处理函数。每一个方法有一些细微的差别，三个都很有用而且互相弥补。</p>
<ul>
<li><strong>debounce:</strong>把突然涌进的事件（键盘事件）归位一个</li>
<li><strong>throttle:</strong>保证持续执行方法分隔为每Xms执行一次。就像每200ms监测滚动位置来触发css动画。</li>
<li><strong>requestAnimationFrame:</strong>throttle的替代方案，当你的方法需要重新计算和渲染元素同时你需要更平滑的变动或动画。注意：IE9- 不支持。</li>
</ul>
<ol>
<li><a href="https://blog.coding.net/blog/the-difference-between-throttle-and-debounce-in-underscorejs" target="_blank" rel="external">https://blog.coding.net/blog/the-difference-between-throttle-and-debounce-in-underscorejs</a></li>
<li><a href="https://css-tricks.com/the-difference-between-throttling-and-debouncing/" target="_blank" rel="external">https://css-tricks.com/the-difference-between-throttling-and-debouncing/</a></li>
<li><a href="http://stackoverflow.com/questions/25991367/difference-between-throttling-and-debouncing-a-function" target="_blank" rel="external">http://stackoverflow.com/questions/25991367/difference-between-throttling-and-debouncing-a-function</a></li>
<li><a href="http://demo.nimius.net/debounce_throttle/" target="_blank" rel="external">http://demo.nimius.net/debounce_throttle/</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>






  
    <article id="post-Promise方法中的异常处理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/27/Promise方法中的异常处理/" class="article-date">
  	<time datetime="2016-03-27T13:49:13.000Z" itemprop="datePublished">Mar 27 2016</time>
</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/promise/">promise</a></li></ul>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/27/Promise方法中的异常处理/">Promise reject and throw Error</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>以Promise为基础的方法应该reject的Promise，而不该抛出异常。</p>
<p>原因是如果这样做将需要两种错误处理方式：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function asyncFunc() &#123;</span><br><span class="line">    <span class="keyword">return</span> doSomethingAsync() // (A)</span><br><span class="line">    .then(<span class="literal">result</span> =&gt; &#123;</span><br><span class="line">        ···</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(error =&gt; &#123; // (B)</span><br><span class="line">        ···</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若在A行执行的异步方法抛出异常，但是B行并不会做出反应。</p>
<p><strong>Promise方法中处理异常</strong></p>
<p>如果异常在then和catch的回调函数中抛出并不会有问题，因为这两个方法会转变异常为reject。<br>可是若在异步方法中添加了同步方法：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function asyncFunc() &#123;</span><br><span class="line">    doSomethingSync(); // (A)</span><br><span class="line">    <span class="keyword">return</span> doSomethingAsync()</span><br><span class="line">    .then(<span class="literal">result</span> =&gt; &#123;</span><br><span class="line">        ···</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在A行抛出异常，整个方法都会抛出一个异常，有两个方法可以处理此问题：</p>
<p>1.返回rejected Promise</p>
<p>可以捕获异常，然后作为rejected Promises返回：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function asyncFunc() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doSomethingSync();</span><br><span class="line">        <span class="keyword">return</span> doSomethingAsync()</span><br><span class="line">        .then(<span class="literal">result</span> =&gt; &#123;</span><br><span class="line">            ···</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Promise</span>.reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.在回调中执行同步代码</p>
<p>以Promise.resolve()开启一个then的链式调用然后在回调中执行同步代码：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function asyncFunc() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Promise</span>.resolve()</span><br><span class="line">    .then(() =&gt; &#123;</span><br><span class="line">        doSomethingSync();</span><br><span class="line">        <span class="keyword">return</span> doSomethingAsync();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="literal">result</span> =&gt; &#123;</span><br><span class="line">        ···</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>译：<a href="http://www.2ality.com/2016/03/promise-rejections-vs-exceptions.html" target="_blank" rel="external">http://www.2ality.com/2016/03/promise-rejections-vs-exceptions.html</a></p>

      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>






  
    <article id="post-读《你的知识需要管理》感" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/26/读《你的知识需要管理》感/" class="article-date">
  	<time datetime="2016-03-26T10:00:45.000Z" itemprop="datePublished">Mar 26 2016</time>
</a>
      
      
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/26/读《你的知识需要管理》感/">读《你的知识需要管理》感</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上周间隔的读了《你的知识需要管理》这本书，作者田志刚，<a href="http://www.kmcenter.org/html/tianzhigang/" target="_blank" rel="external">这里</a>是他的一些文章。现在这个社会最重要的是人，人最重要的是有自己的能力，能力体现在对知识的最佳利用。</p>
<p>现在不在是文革时期，稍微有点知识（文化）就可以沾沾自喜，现在信息不对称性在慢慢降低，靠一条信息就可以致富的时代一去不返了。现在我们老家的人，通过手机上网就很方便的获取信息和知识。所以在现在如何更好的利用信息，更好的管理自己的知识显得尤为重要。</p>
<p>在现在信息泛滥的时代，如果没有好的信息和知识管理方案，就会迷失在这个信息流中。不要用个人有限的生命去获取无限的信息和知识。</p>
<p>本书提出了<strong>五步打造个人知识力</strong>：</p>
<ol>
<li>学习：在知识社会，我们每个人只有持续不断地高效学习。</li>
<li>保存：普通人的大脑容量有限，充分利用工具保存知识。</li>
<li>共享：让别人知道你知道，提高个人的影响力。</li>
<li>使用：将知识应用生活／工作中。</li>
<li>创新：站巨人的肩膀，看的更远。</li>
</ol>
<p>我前几点都没有做好，更不要谈创新。有些人可能会疑问学习都不会，学校白呆了。有句话说的很好：听过许多道理，依旧过不好这一生。虽然上了好多年学，可是学习这种技能并不是每个人都能习的。书中提到一个典型的例子：数据／信息和知识的区别？</p>
<p>首先给一个数字：37.5，然后赋予这个数字一些信息：37.5度，最后这个根据医学知识判断37.5度是否超过人体正常温度。</p>
<p>这个演变的过程就是：<strong>数据－&gt;信息－&gt;知识</strong>。</p>
<p>刚开始37.5这个数字是没有任何意义的，慢慢的有了一些意义表示提问，然后根据科学知识给出决策和行动。</p>
<p>现在大家应该都玩知乎／微博，每天刷的不亦乐乎，当时是不是感觉自己懂了很多？充实很多？事后想想多数都是没有用的信息，真正有用的没用多少。这就是把自己淹没在信息流中。</p>
<p>在很好的区分这三者之后，就会面临一系列问题：</p>
<p><strong>为何学习？</strong></p>
<p>这个每个人有不同的动力，更好的工作，更好的生活等</p>
<p><strong>如何学习知识？</strong></p>
<p>大家肯定会立马想到：认真 努力 持之以恒等这些积极向上的词语，这些都没有错，但是可能忽略了两个问题：<strong>方向 专注</strong>。方向很重要，如果南辕北辙，学了又有什么用，在一个错误的方向使劲还不如原地踏步。好，你说方向是吧，我选择了很多方法，今天学一下这个明天看看这个。那这会造成什么呢？知识的深度不够，若不够深知识就会变成常识，常识怎么会提高个人的竞争力呢？</p>
<p><strong>如何保存知识？</strong></p>
<p>想必大家都有这样的经历，在网上看到一个免费的PDF文件，感觉对自己有点用，然后立马下在下来，然后随便翻翻就丢在那里。或者微博或知乎看到一个很不错的东西就立马转发或者关注，再或者看到一个很好的博客就添加到浏览器收藏夹再也没有打开过。或许你在用的时候感觉曾经看到过相关的东西，也确实收藏了，但保存到哪里却不记得了。</p>
<p>这都是没有做好知识的保存工作，第一种就是无限制的保存，硬盘全部占满也无济于事，第二种没有分门别类。</p>
<p>大脑容量有限，我们要善于借助工具，要深度或者回看的文章都用Pocket保存，浏览器书签分了好多类别（其实类别一多也不行，不易查找），日常工作用有道笔记，资料存储用百度云盘（里面该整理一下）。存的资料多其实有时候会给自己一种错觉：我知道的很多，会很多东西。其实不然，那些知识并没有融合到自己脑子里，看到这里翻翻自己以前存的资料（都有系统时间，看是多久之前的）。</p>
<p><strong>如何共享知识？</strong></p>
<p>共享知识其实就是让别人知道你知道，提高自己的影响力以及实现个人的价值。其实途径很多，看个人性格爱好，如果比较内向，可以选择博客，微信公众号；如果外向，善于交际，可以选择做演讲，做视频或者直播代码。最简单的就是在工作中，用自己的知识去解决自己和同事遇到的问题，慢慢提升自己的团队影响力。共享知识也是一种考验自己对相关知识理解是否到位？若对一个知识点不能用简单明了的语言表达出来，说明掌握的还是不够到位。</p>
<p><strong>如何使用知识？</strong></p>
<p>上面也说了应用到工作中，才能去除掉满腹经纶，无法施展的郁闷心情。</p>
<p><strong>如何创新知识？</strong></p>
<p>普通人，做到前面四点已经不容易。在这里就不谈了，如果有兴趣就看看上面说的那本书吧。</p>
<p>上面五点的关系如下图：</p>
<p><img src="/assets/images/pkm.png" alt="img"></p>
<p>在附一张学习体系总结图：</p>
<p><img src="/assets/images/xuexi.png" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>






  
    <article id="post-DOM小结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/20/DOM小结/" class="article-date">
  	<time datetime="2016-03-20T01:55:13.000Z" itemprop="datePublished">Mar 20 2016</time>
</a>
      
      
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/20/DOM小结/">DOM小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>DOM是针对HTML和XML文档的一个API（应用程序编程入口）。DOM描绘了一个层次化的节点树，允许开发人员添加／移除和修改页面某一部分。</p>
</blockquote>
<p>注：从上面的引述中可以得知，DOM不仅存在于HTML中，DOM也不是JS的一部分。DOM只是提供了一些规范，具体JS就是根据这些规范去实现它提出的一些接口 。</p>
<p>这里有个问题， <strong>IE中所有的DOM对象都是以COM对象实现的，所以DOM对象和JS原生对象行为或活动特点不一致。</strong>这也导致JS对象引用IE DOM对象会内存泄漏。</p>
<p>JS中实现了一个Node类型，所有节点都集成它，所以会共享相同的属性和方法。</p>
<p>下面就用个思维导图总结下：</p>
<p><img src="/assets/images/dom.png" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>






  
    <article id="post-module-exports和exports的区别" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/16/module-exports和exports的区别/" class="article-date">
  	<time datetime="2016-03-16T09:58:59.000Z" itemprop="datePublished">Mar 16 2016</time>
</a>
      
      
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/16/module-exports和exports的区别/">module.exports和exports的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在前端现在盛行</p>
<p><a href="https://cnodejs.org/topic/5231a630101e574521e45ef8" target="_blank" rel="external">https://cnodejs.org/topic/5231a630101e574521e45ef8</a><br><a href="https://github.com/chemdemo/chemdemo.github.io/issues/2" target="_blank" rel="external">https://github.com/chemdemo/chemdemo.github.io/issues/2</a></p>

      
    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
  
</article>






  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  


      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Zhuxy
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>
  <script src="/js/main.js" type="text/javascript"></script>

  </div>
</body>
</html>